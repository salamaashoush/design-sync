import type {
  ProcessedToken,
  ProcessorExtension,
  ProcessorModes,
  ProcessorOptions,
  TokenProcessorInterface,
  TokenQueryBuilder,
} from "@design-sync/w3c-dtfm";

// ============================================================================
// Plugin Output Types
// ============================================================================

/**
 * Output file generated by a plugin
 */
export interface PluginOutputFile {
  /** Relative path for the output file */
  path: string;
  /** File content */
  content: string;
  /** File type hint for formatting */
  type?: "js" | "ts" | "css" | "json";
}

// ============================================================================
// Plugin Metadata
// ============================================================================

/**
 * Plugin metadata for identification and documentation
 */
export interface PluginMeta {
  /** Unique plugin name */
  name: string;
  /** Optional semantic version */
  version?: string;
  /** Optional description */
  description?: string;
}

// ============================================================================
// Plugin Logger
// ============================================================================

/**
 * Scoped logger for plugin use
 */
export interface PluginLogger {
  debug(message: string, ...args: unknown[]): void;
  info(message: string, ...args: unknown[]): void;
  warn(message: string, ...args: unknown[]): void;
  error(message: string, ...args: unknown[]): void;
  success(message: string, ...args: unknown[]): void;
}

// ============================================================================
// Plugin Context Types
// ============================================================================

/**
 * Context provided to plugin initialization hook
 */
export interface PluginInitContext {
  /** Logger scoped to the plugin */
  readonly logger: PluginLogger;
  /** Full configuration */
  readonly config: DesignSyncConfig;
}

/**
 * Context provided to plugin build and lifecycle hooks
 */
export interface PluginContext {
  /** Token processor instance (already processed) */
  readonly processor: TokenProcessorInterface;
  /** Create a query builder for fluent token queries */
  readonly query: () => TokenQueryBuilder<ProcessedToken>;
  /** Get iterator over all processed tokens */
  readonly tokens: () => IterableIterator<ProcessedToken>;
  /** Get a token by its path */
  readonly getToken: (path: string) => ProcessedToken | undefined;
  /** Mode configuration (defaultMode, requiredModes, availableModes) */
  readonly modes: ProcessorModes;
  /** Logger scoped to the plugin */
  readonly logger: PluginLogger;
  /** Full configuration */
  readonly config: DesignSyncConfig;
}

// ============================================================================
// Plugin Result Types
// ============================================================================

/**
 * Result from a plugin's build method
 */
export interface PluginBuildResult {
  /** Files to write */
  files: PluginOutputFile[];
  /** Optional warnings to report */
  warnings?: string[];
}

// ============================================================================
// Plugin Interface
// ============================================================================

/**
 * Design Sync plugin interface with lifecycle hooks
 *
 * Plugins receive a `PluginContext` with access to the `TokenProcessor` API:
 * - `context.processor` - The token processor (already processed)
 * - `context.query()` - Fluent query builder with type narrowing
 * - `context.tokens()` - Iterator over all tokens
 * - `context.getToken(path)` - Get a specific token
 * - `context.modes` - Mode configuration
 *
 * @example
 * ```typescript
 * const myPlugin: DesignSyncPlugin = {
 *   meta: { name: 'my-plugin', version: '1.0.0' },
 *   async build(context) {
 *     const colors = context.query().ofType('color').toArray();
 *     return {
 *       files: [{
 *         path: 'colors.css',
 *         content: colors.map(t => `--${t.name}: ${t.toCSS()};`).join('\n')
 *       }]
 *     };
 *   }
 * };
 * ```
 */
export interface DesignSyncPlugin {
  /** Plugin metadata */
  readonly meta: PluginMeta;

  /**
   * Called once when the plugin is registered, before processing starts.
   * Use this for setup tasks that don't need processed tokens.
   */
  onInit?(context: PluginInitContext): Promise<void> | void;

  /**
   * Called before the build method runs.
   * Tokens are processed and available via context.
   */
  onBeforeBuild?(context: PluginContext): Promise<void> | void;

  /**
   * Main build method - generates output files.
   * Tokens are processed and available via context.
   */
  build(context: PluginContext): Promise<PluginBuildResult> | PluginBuildResult;

  /**
   * Called after build completes successfully.
   * Useful for cleanup or reporting.
   */
  onAfterBuild?(context: PluginContext, result: PluginBuildResult): Promise<void> | void;

  /**
   * Called if an error occurs during build.
   * Useful for error handling or cleanup.
   */
  onError?(error: Error, context: PluginContext): Promise<void> | void;
}

// ============================================================================
// Build Options & Results
// ============================================================================

/**
 * Options for the build process
 */
export interface BuildOptions {
  /**
   * Run plugins in parallel using Promise.allSettled.
   * If false, plugins run sequentially.
   * @default false
   */
  parallel?: boolean;

  /**
   * Dry run mode - don't write files, just return what would be written.
   * @default false
   */
  dryRun?: boolean;

  /**
   * AbortSignal to cancel the build
   */
  signal?: AbortSignal;
}

/**
 * Result of a single plugin's execution
 */
export interface PluginResult {
  /** Plugin name */
  plugin: string;
  /** Whether the plugin succeeded */
  success: boolean;
  /** Files generated (and written unless dryRun) */
  files: PluginOutputFile[];
  /** Warnings from the plugin */
  warnings: string[];
  /** Error if the plugin failed */
  error?: Error;
}

/**
 * Result of the full build process
 */
export interface BuildResult {
  /** Whether the build succeeded overall */
  success: boolean;
  /** Results from each plugin */
  plugins: PluginResult[];
  /** Total files written */
  totalFiles: number;
  /** Duration in milliseconds */
  durationMs: number;
}

// ============================================================================
// Configuration Types
// ============================================================================

/**
 * Design Sync configuration options that map to ProcessorOptions
 */
export interface DesignSyncProcessorConfig {
  /**
   * Default mode name
   * @default 'default'
   */
  defaultMode?: string;

  /**
   * Required modes that tokens should have values for
   * @default []
   */
  requiredModes?: string[];

  /**
   * Token filter to only process matching tokens
   */
  filter?: ProcessorOptions["filter"];

  /**
   * Custom value overrides by token path
   */
  overrides?: ProcessorOptions["overrides"];

  /**
   * Custom processor extensions
   */
  extensions?: ProcessorExtension[];

  /**
   * Disable builtin extensions (color-modifiers, color-generators)
   * @default false
   */
  disableBuiltinExtensions?: boolean;
}

/**
 * Design Sync TokensManager configuration
 */
export interface DesignSyncConfig extends DesignSyncProcessorConfig {
  /**
   * Remote repository URI to fetch the tokens from (giget format)
   * @example 'gh:owner/repo/path#branch'
   */
  uri: string;

  /**
   * Output directory for the generated files
   */
  out: string;

  /**
   * Authentication token for fetching tokens from remote repository
   * @default undefined
   */
  auth?: string;

  /**
   * Current working directory for resolving config and output
   * @default process.cwd()
   */
  cwd?: string;

  /**
   * Plugins to be used during the build process
   */
  plugins: DesignSyncPlugin[];

  /**
   * Format the generated files using oxfmt
   * @default false
   */
  prettify?: boolean;
}
