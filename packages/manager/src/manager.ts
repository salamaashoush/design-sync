import { toArray } from "@design-sync/utils";
import { createTokenProcessor, TokenProcessorInterface } from "@design-sync/w3c-dtfm";
import type { ConsolaInstance } from "consola";
import { existsSync } from "node:fs";
import { rm } from "node:fs/promises";
import { join } from "node:path";
import { defaultConfig, resolveConfig } from "./config";
import { fetchTokens } from "./fetcher";
import { logger as defaultLogger } from "./logger";
import type {
  BuildOptions,
  BuildResult,
  DesignSyncConfig,
  DesignSyncPlugin,
  PluginBuildResult,
  PluginContext,
  PluginInitContext,
  PluginLogger,
  PluginOutputFile,
  PluginResult,
} from "./types";
import { formatAndWriteFile } from "./writer";

// ============================================================================
// Utilities
// ============================================================================

function wrapWithBanner(file: PluginOutputFile) {
  const { path, content, type } = file;
  const t = type ?? path.split(".").pop() ?? "";

  if (t === "json") {
    return content;
  }
  return `/* This file is generated automatically by Design Sync. Do not edit this file directly. */\n\n${content}`;
}

/**
 * Create a scoped logger for a plugin
 */
function createPluginLogger(baseLogger: ConsolaInstance, pluginName: string): PluginLogger {
  const scoped = baseLogger.withTag(pluginName);
  return {
    debug: (message, ...args) => scoped.debug(message, ...args),
    info: (message, ...args) => scoped.info(message, ...args),
    warn: (message, ...args) => scoped.warn(message, ...args),
    error: (message, ...args) => scoped.error(message, ...args),
    success: (message, ...args) => scoped.success(message, ...args),
  };
}

// ============================================================================
// TokensManager Class
// ============================================================================

/**
 * TokensManager - Core class for processing design tokens and running plugins
 *
 * The manager orchestrates:
 * - Fetching tokens from remote sources
 * - Processing tokens via the TokenProcessor API
 * - Running plugins with full lifecycle support
 * - Writing output files
 *
 * @example
 * ```typescript
 * const manager = new TokensManager();
 * await manager.run({
 *   uri: 'gh:owner/repo/tokens#main',
 *   out: './src/tokens',
 *   plugins: [cssPlugin(), jsonPlugin()]
 * });
 * ```
 */
export class TokensManager {
  private plugins: DesignSyncPlugin[] = [];
  private processor: TokenProcessorInterface | null = null;
  private config: DesignSyncConfig = defaultConfig;
  private tokens: Record<string, unknown> = {};

  constructor(private logger: ConsolaInstance = defaultLogger) {}

  // ============================================================================
  // Public API
  // ============================================================================

  /**
   * Get the token processor instance.
   * Only available after `run()` has been called.
   *
   * @throws Error if called before run()
   */
  getProcessor(): TokenProcessorInterface {
    if (!this.processor) {
      throw new Error("Processor not initialized. Call run() first.");
    }
    return this.processor;
  }

  /**
   * Get the current configuration
   */
  getConfig(): DesignSyncConfig {
    return this.config;
  }

  /**
   * Get the logger instance
   */
  getLogger(): ConsolaInstance {
    return this.logger;
  }

  // ============================================================================
  // Main Run Method
  // ============================================================================

  /**
   * Run the token processing pipeline.
   *
   * Steps:
   * 1. Resolve configuration
   * 2. Fetch tokens from source
   * 3. Initialize processor
   * 4. Process tokens
   * 5. Run plugin lifecycle (init -> beforeBuild -> build -> afterBuild)
   * 6. Write output files
   *
   * @param configOverride - Optional configuration overrides
   * @param tokens - Optional tokens object (skips fetching if provided)
   * @param buildOptions - Optional build options (parallel, dryRun, signal)
   * @returns Build result with plugin results and timing
   */
  async run(
    configOverride?: Partial<DesignSyncConfig>,
    tokens?: Record<string, unknown>,
    buildOptions: BuildOptions = {},
  ): Promise<BuildResult> {
    const startTime = performance.now();
    this.logger.start("Processing tokens...");

    // 1. Resolve configuration
    this.config = await resolveConfig(configOverride);

    // 2. Fetch tokens
    if (!tokens) {
      await this.fetch();
    } else {
      this.tokens = tokens;
    }

    // 3. Initialize processor
    this.initializeProcessor();

    // 4. Process tokens
    await this.processor!.process();

    // 5. Register plugins
    this.registerPlugins(this.config.plugins);

    // 6. Clean output directory
    const outPath = join(process.cwd(), this.config.out);
    if (existsSync(outPath)) {
      await rm(outPath, { recursive: true });
    }

    // 7. Run plugins
    const pluginResults = await this.runPlugins(buildOptions);

    // 8. Calculate results
    const durationMs = performance.now() - startTime;
    const success = pluginResults.every((r) => r.success);
    const totalFiles = pluginResults.reduce((sum, r) => sum + r.files.length, 0);

    if (success) {
      this.logger.info(`Done in ${(durationMs / 1000).toFixed(2)}s`);
    } else {
      const failedPlugins = pluginResults.filter((r) => !r.success).map((r) => r.plugin);
      this.logger.error(`Build failed. Failed plugins: ${failedPlugins.join(", ")}`);
    }

    return {
      success,
      plugins: pluginResults,
      totalFiles,
      durationMs,
    };
  }

  /**
   * Register plugins with the manager.
   */
  use(plugin: DesignSyncPlugin | DesignSyncPlugin[]) {
    const plugins = toArray(plugin);
    this.registerPlugins(plugins);
  }

  // ============================================================================
  // Private Methods
  // ============================================================================

  private async fetch(uri?: string, auth?: string) {
    const r = uri || this.config.uri;
    if (!r) {
      this.logger.error("No repo provided");
      return;
    }
    const a = auth || this.config.auth;
    this.tokens = await fetchTokens(r, a);
  }

  private initializeProcessor() {
    this.processor = createTokenProcessor(this.tokens, {
      defaultMode: this.config.defaultMode,
      requiredModes: this.config.requiredModes,
      filter: this.config.filter,
      overrides: this.config.overrides,
      extensions: this.config.extensions,
      disableBuiltinExtensions: this.config.disableBuiltinExtensions,
    });
  }

  private registerPlugins(plugins: DesignSyncPlugin[]) {
    for (const plugin of plugins) {
      const name = plugin.meta.name;

      if (this.plugins.some((p) => p.meta.name === name)) {
        this.logger.warn(`Plugin ${name} already registered`);
        continue;
      }

      this.plugins.push(plugin);
    }
  }

  private createPluginInitContext(plugin: DesignSyncPlugin): PluginInitContext {
    return {
      logger: createPluginLogger(this.logger, plugin.meta.name),
      config: this.config,
    };
  }

  private createPluginContext(plugin: DesignSyncPlugin): PluginContext {
    const processor = this.processor!;
    return {
      processor,
      query: () => processor.query(),
      tokens: () => processor.tokens(),
      getToken: (path) => processor.get(path),
      modes: processor.modes,
      logger: createPluginLogger(this.logger, plugin.meta.name),
      config: this.config,
    };
  }

  private async runPlugins(options: BuildOptions): Promise<PluginResult[]> {
    const { parallel = false, dryRun = false, signal } = options;

    // Run onInit for all plugins first
    for (const plugin of this.plugins) {
      if (signal?.aborted) {
        throw new Error("Build aborted");
      }
      if (plugin.onInit) {
        const initContext = this.createPluginInitContext(plugin);
        await plugin.onInit(initContext);
      }
    }

    // Run build phase
    if (parallel) {
      return this.runPluginsParallel(dryRun, signal);
    } else {
      return this.runPluginsSequential(dryRun, signal);
    }
  }

  private async runPluginsSequential(
    dryRun: boolean,
    signal?: AbortSignal,
  ): Promise<PluginResult[]> {
    const results: PluginResult[] = [];

    for (const plugin of this.plugins) {
      if (signal?.aborted) {
        throw new Error("Build aborted");
      }
      const result = await this.runSinglePlugin(plugin, dryRun);
      results.push(result);
    }

    return results;
  }

  private async runPluginsParallel(dryRun: boolean, signal?: AbortSignal): Promise<PluginResult[]> {
    const promises = this.plugins.map((plugin) => this.runSinglePlugin(plugin, dryRun));

    if (signal) {
      // Add abort handling
      const abortPromise = new Promise<never>((_, reject) => {
        signal.addEventListener("abort", () => reject(new Error("Build aborted")));
      });
      await Promise.race([Promise.allSettled(promises), abortPromise]);
    }

    const settled = await Promise.allSettled(promises);

    return settled.map((result, index) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        return {
          plugin: this.plugins[index].meta.name,
          success: false,
          files: [],
          warnings: [],
          error: result.reason instanceof Error ? result.reason : new Error(String(result.reason)),
        };
      }
    });
  }

  private async runSinglePlugin(plugin: DesignSyncPlugin, dryRun: boolean): Promise<PluginResult> {
    const context = this.createPluginContext(plugin);
    const pluginName = plugin.meta.name;

    try {
      // onBeforeBuild
      if (plugin.onBeforeBuild) {
        await plugin.onBeforeBuild(context);
      }

      // build
      const result: PluginBuildResult = await plugin.build(context);

      // Write files (unless dry run)
      if (!dryRun) {
        await Promise.all(
          result.files.map(async (file) => {
            const path = join(this.config.out, file.path);
            await formatAndWriteFile(path, wrapWithBanner(file), this.config.prettify);
            context.logger.success(`File ${path} created successfully`);
          }),
        );
      }

      // onAfterBuild
      if (plugin.onAfterBuild) {
        await plugin.onAfterBuild(context, result);
      }

      // Log warnings
      if (result.warnings) {
        for (const warning of result.warnings) {
          context.logger.warn(warning);
        }
      }

      return {
        plugin: pluginName,
        success: true,
        files: result.files,
        warnings: result.warnings ?? [],
      };
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));

      // onError
      if (plugin.onError) {
        try {
          await plugin.onError(err, context);
        } catch {
          // Ignore errors in error handler
        }
      }

      context.logger.error(`Plugin ${pluginName} failed:`, err.message);

      return {
        plugin: pluginName,
        success: false,
        files: [],
        warnings: [],
        error: err,
      };
    }
  }
}
