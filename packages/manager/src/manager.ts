import { toArray } from '@design-sync/utils';
import { TokensWalker, TokensWalkerFilter } from '@design-sync/w3c-dtfm';
import { existsSync } from 'node:fs';
import { rm } from 'node:fs/promises';
import { join } from 'node:path';
import { defaultConfig, resolveConfig } from './config';
import { fetchTokens } from './fetcher';
import { logger as defaultLogger } from './logger';
import { DesignSyncConfig } from './types';
import { formatAndWriteFile } from './writer';

export interface TokensManagerPluginFile {
  path: string;
  content: string;
  type?: 'js' | 'ts' | 'css' | 'json';
}
export interface TokensManagerPlugin {
  name: string;
  filter?: TokensWalkerFilter;
  build: (walker: TokensManager) => Promise<TokensManagerPluginFile[]>;
}

function wrapWithBanner(file: TokensManagerPluginFile) {
  const { path, content, type } = file;
  const t = type ?? path.split('.').pop() ?? '';

  if (t === 'json') {
    return content;
  }
  return `/* This file is generated automatically by Design Sync. Do not edit this file directly. */\n\n${content}`;
}
export class TokensManager {
  private plugins: TokensManagerPlugin[] = [];
  private walker = new TokensWalker();
  private config: DesignSyncConfig = defaultConfig;

  constructor(private logger = defaultLogger) {}

  getWalker() {
    return this.walker;
  }

  getLogger() {
    return this.logger;
  }

  getConfig() {
    return this.config;
  }

  private async fetch(uri?: string, auth?: string) {
    const r = uri || this.config.uri;
    if (!r) {
      this.logger.error('No repo provided');
    }
    const a = auth || this.config.auth;
    const tokens = await fetchTokens(r, a);
    this.walker.setTokens(tokens);
  }

  private setWalkerOptions() {
    this.walker.setOptions({
      defaultMode: this.config.defaultMode,
      requiredModes: this.config.requiredModes,
      filter: this.config.filter,
      disableDefaultSchemaExtensions: this.config.disableDefaultSchemaExtensions,
      schemaExtensions: this.config.schemaExtensions,
      overrides: this.config.overrides,
    });
  }

  async run(configOverride?: Partial<DesignSyncConfig>, tokens?: Record<string, unknown>) {
    const startTime = performance.now();
    this.logger.start('Processing tokens...');
    this.config = await resolveConfig(configOverride);
    this.setWalkerOptions();
    this.use(this.config.plugins);
    if (!tokens) {
      await this.fetch();
    } else {
      this.walker.setTokens(tokens);
    }
    // clean the dist folder
    const outPath = join(process.cwd(), this.config.out);
    if (existsSync(outPath)) {
      await rm(outPath, { recursive: true });
    }
    try {
      // run the plugins
      for (const plugin of this.plugins) {
        const files = await plugin.build(this);
        await Promise.all(
          files.map(async (file) => {
            const path = join(this.config.out, file.path);
            await formatAndWriteFile(path, wrapWithBanner(file), this.config.prettify);
            this.logger.withTag(plugin.name).success(`File ${path} created successfully`);
          }),
        );
      }
      this.logger.info(`Done in ${((performance.now() - startTime) / 1000).toFixed(2)}s`);
    } catch (e) {
      this.logger.error('Failed to build tokens', e);
    }
  }

  use(plugin: TokensManagerPlugin | TokensManagerPlugin[]) {
    const plugins = toArray(plugin);
    for (const plugin of plugins) {
      if (this.plugins.some((p) => p.name === plugin.name)) {
        this.logger.warn(`Plugin ${plugin.name} already registered`);
        continue;
      }
      this.plugins.push(plugin);
    }
  }
}
