import{MessageChannel as O,isMainThread as F}from"worker_threads";import{i as N,s as U}from"../node-features-a792cc3d.mjs";import v from"module";import{installSourceMapSupport as P,shouldStripSourceMap as A,stripSourceMap as D}from"../source-map.mjs";import h from"path";import{fileURLToPath as _,pathToFileURL as L}from"url";import{t as b,a as x}from"../index-c4b20163.mjs";import{r as J}from"../resolve-ts-path-a8cb04a4.mjs";import{parseTsconfig as I,getTsconfig as $,createFilesMatcher as C,createPathsMatcher as W}from"get-tsconfig";import T from"fs";import"source-map-support";import"esbuild";import"crypto";import"os";const q=()=>{const{port1:t,port2:r}=new O;P(t),process.send&&t.addListener("message",s=>{s.type==="dependency"&&process.send(s)}),t.unref(),v.register("./index.mjs",{parentURL:import.meta.url,data:{port:r},transferList:[r]})},m=new Map;async function G(t){if(m.has(t))return m.get(t);if(!await T.promises.access(t).then(()=>!0,()=>!1)){m.set(t,void 0);return}const s=await T.promises.readFile(t,"utf8");try{const o=JSON.parse(s);return m.set(t,o),o}catch{throw new Error(`Error parsing: ${t}`)}}async function H(t){let r=new URL("package.json",t);for(;!r.pathname.endsWith("/node_modules/package.json");){const s=_(r),o=await G(s);if(o)return o;const a=r;if(r=new URL("../package.json",r),r.pathname===a.pathname)break}}async function X(t){var r;const s=await H(t);return(r=s==null?void 0:s.type)!=null?r:"commonjs"}const f=process.env.TSX_TSCONFIG_PATH?{path:h.resolve(process.env.TSX_TSCONFIG_PATH),config:I(process.env.TSX_TSCONFIG_PATH)}:$(),K=f&&C(f),E=f&&W(f),k="file://",g=/\.([cm]?ts|[tj]sx)($|\?)/,Q=/\.json(?:$|\?)/,z=t=>{const r=h.extname(t);if(r===".json")return"json";if(r===".mjs"||r===".mts")return"module";if(r===".cjs"||r===".cts")return"commonjs"},B=t=>{const r=z(t);if(r)return r;if(g.test(t))return X(t)},M=P(),R=/\/(?:$|\?)/;let u,d=process.send?process.send.bind(process):void 0;const V=async t=>{if(!t)throw new Error(`tsx must be loaded with --import instead of --loader
The --loader flag was deprecated in Node v20.6.0`);const{port:r}=t;u=r,d=r.postMessage.bind(r)},Y=({port:t})=>(u=t,d=t.postMessage.bind(t),`
	const require = getBuiltin('module').createRequire("${import.meta.url}");
	require('tsx/source-map').installSourceMapSupport(port);
	if (process.send) {
		port.addListener('message', (message) => {
			if (message.type === 'dependency') {
				process.send(message);
			}
		});
	}
	port.unref(); // Allows process to exit without waiting for port to close
	`),l=async(t,r,s)=>{const o=await t(r,s);return!o.format&&o.url.startsWith(k)&&(o.format=await B(o.url)),o},Z=[".js",".json",".ts",".tsx",".jsx"];async function y(t,r,s){const[o,a]=t.split("?");let c;for(const n of Z)try{return await l(s,o+n+(a?`?${a}`:""),r)}catch(e){if(c===void 0&&e instanceof Error){const{message:i}=e;e.message=e.message.replace(`${n}'`,"'"),e.stack=e.stack.replace(i,e.message),c=e}}throw c}async function S(t,r,s){const o=R.test(t),a=o?"index":"/index",[c,n]=t.split("?");try{return await y(c+a+(n?`?${n}`:""),r,s)}catch(e){if(!o)try{return await y(t,r,s)}catch{}const i=e,{message:p}=i;throw i.message=i.message.replace(`${a.replace("/",h.sep)}'`,"'"),i.stack=i.stack.replace(p,i.message),i}}const tt=/^\.{1,2}\//,j=async function(t,r,s,o){var a;if(R.test(t))return await S(t,r,s);const c=t.startsWith(k)||tt.test(t);if(E&&!c&&!((a=r.parentURL)!=null&&a.includes("/node_modules/"))){const n=E(t);for(const e of n)try{return await j(L(e).toString(),r,s)}catch{}}if(g.test(r.parentURL)){const n=J(t);if(n)for(const e of n)try{return await l(s,e,r)}catch(i){const{code:p}=i;if(p!=="ERR_MODULE_NOT_FOUND"&&p!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw i}}try{return await l(s,t,r)}catch(n){if(n instanceof Error&&!o){const{code:e}=n;if(e==="ERR_UNSUPPORTED_DIR_IMPORT")try{return await S(t,r,s)}catch(i){if(i.code!=="ERR_PACKAGE_IMPORT_NOT_DEFINED")throw i}if(e==="ERR_MODULE_NOT_FOUND")try{return await y(t,r,s)}catch{}}throw n}},w=N?"importAttributes":"importAssertions",rt=async function(t,r,s){var o;d&&d({type:"dependency",path:t}),Q.test(t)&&(r[w]||(r[w]={}),r[w].type="json");const a=await s(t,r);if(!a.source)return a;const c=t.startsWith("file://")?_(t):t;let n=a.source.toString();if(A&&(n=D(n)),a.format==="json"||g.test(t)){const e=await b(n,c,{tsconfigRaw:(o=K)==null?void 0:o(c)});return{format:"module",source:M(e,t,u)}}if(a.format==="module"){const e=x(c,n);e&&(a.source=M(e,t,u))}return a};U&&F&&q();export{Y as globalPreload,V as initialize,rt as load,j as resolve};
