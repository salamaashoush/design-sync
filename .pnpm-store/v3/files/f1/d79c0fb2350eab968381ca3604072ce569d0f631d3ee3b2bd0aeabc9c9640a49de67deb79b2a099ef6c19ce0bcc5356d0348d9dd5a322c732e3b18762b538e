{"version":3,"sources":["../src/array.ts","../src/assertion.ts","../src/create-generate-id.ts","../src/create-global-listeners.ts","../src/dom.ts","../src/enums.ts","../src/platform.ts","../src/events.ts","../src/external.ts","../src/focus-without-scrolling.ts","../src/tabbable.ts","../src/focus-manager.ts","../src/get-scroll-parent.ts","../src/is-virtual-event.ts","../src/noop.ts","../src/number.ts","../src/polygon.ts","../src/props.ts","../src/run-after-transition.ts","../src/scroll-into-view.ts","../src/styles.ts"],"names":["EventKey","tabbableElements","last"],"mappings":"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","sourcesContent":["/*!\n * Portions of this file are based on code from ariakit.\n * MIT Licensed, Copyright (c) Diego Haz.\n *\n * Credits to the Ariakit team:\n * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit-utils/src/array.ts\n */\n\n/**\n * Immutably adds an item at the given index to an array.\n */\nexport function addItemToArray<T extends any[]>(array: T, item: T[number], index = -1) {\n  if (!(index in array)) {\n    return [...array, item] as T;\n  }\n  return [...array.slice(0, index), item, ...array.slice(index)] as T;\n}\n\n/**\n * Immutably removes an item from an array.\n */\nexport function removeItemFromArray<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n\n  return updatedArray;\n}\n","/*!\n * Original code by Chakra UI\n * MIT Licensed, Copyright (c) 2019 Segun Adebayo.\n *\n * Credits to the Chakra UI team:\n * https://github.com/chakra-ui/chakra-ui/blob/main/packages/utils/src/assertion.ts\n */\n\n// Number assertions\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\";\n}\n\n// Array assertions\nexport function isArray<T>(value: any): value is Array<T> {\n  return Array.isArray(value);\n}\n\n// String assertions\nexport function isString(value: any): value is string {\n  return Object.prototype.toString.call(value) === \"[object String]\";\n}\n\n// Function assertions\nexport function isFunction<T extends Function = Function>(value: any): value is T {\n  return typeof value === \"function\";\n}\n","import { Accessor } from \"solid-js\";\n\n/**\n * Create a function that generate an id from a `baseId` and `suffix`.\n */\nexport function createGenerateId(baseId: Accessor<string>) {\n  return (suffix: string) => `${baseId()}-${suffix}`;\n}\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/solidjs-community/solid-aria/blob/2c5f54feb5cfea514b1ee0a52d0416878f882351/packages/utils/src/createGlobalListeners.ts\n */\n\nimport { onCleanup } from \"solid-js\";\n\ninterface GlobalListeners {\n  addGlobalListener<K extends keyof DocumentEventMap>(\n    el: EventTarget,\n    type: K,\n    listener: (this: Document, ev: DocumentEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n\n  addGlobalListener(\n    el: EventTarget,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n\n  removeGlobalListener<K extends keyof DocumentEventMap>(\n    el: EventTarget,\n    type: K,\n    listener: (this: Document, ev: DocumentEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void;\n\n  removeGlobalListener(\n    el: EventTarget,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void;\n\n  removeAllGlobalListeners(): void;\n}\n\nexport function createGlobalListeners(): GlobalListeners {\n  const globalListeners = new Map();\n\n  const addGlobalListener = (eventTarget: any, type: any, listener: any, options: any) => {\n    // Make sure we remove the listener after it is called with the `once` option.\n    const fn = options?.once\n      ? (...args: any) => {\n          globalListeners.delete(listener);\n          listener(...args);\n        }\n      : listener;\n    globalListeners.set(listener, { type, eventTarget, fn, options });\n    eventTarget.addEventListener(type, listener, options);\n  };\n\n  const removeGlobalListener = (eventTarget: any, type: any, listener: any, options: any) => {\n    const fn = globalListeners.get(listener)?.fn || listener;\n    eventTarget.removeEventListener(type, fn, options);\n    globalListeners.delete(listener);\n  };\n\n  const removeAllGlobalListeners = () => {\n    globalListeners.forEach((value, key) => {\n      removeGlobalListener(value.eventTarget, value.type, key, value.options);\n    });\n  };\n\n  onCleanup(() => {\n    removeAllGlobalListeners();\n  });\n\n  return { addGlobalListener, removeGlobalListener, removeAllGlobalListeners };\n}\n","/*!\n * Portions of this file are based on code from ariakit.\n * MIT Licensed, Copyright (c) Diego Haz.\n *\n * Credits to the Ariakit team:\n * https://github.com/ariakit/ariakit/blob/232bc79018ec20967fec1e097a9474aba3bb5be7/packages/ariakit-utils/src/dom.ts\n */\n\n/**\n * Similar to `Element.prototype.contains`, but a little faster when `element` is the same as `child`.\n */\nexport function contains(parent: Node | undefined, child: Node | null) {\n  if (!parent) {\n    return false;\n  }\n\n  return parent === child || parent.contains(child);\n}\n\n/**\n * Returns `element.ownerDocument.activeElement`.\n */\nexport function getActiveElement(node?: Node | null, activeDescendant = false): HTMLElement | null {\n  const { activeElement } = getDocument(node);\n\n  if (!activeElement?.nodeName) {\n    // In IE11, activeElement might be an empty object if we're interacting\n    // with elements inside an iframe.\n    return null;\n  }\n\n  if (isFrame(activeElement) && activeElement.contentDocument) {\n    return getActiveElement(activeElement.contentDocument.body, activeDescendant);\n  }\n\n  if (activeDescendant) {\n    const id = activeElement.getAttribute(\"aria-activedescendant\");\n\n    if (id) {\n      const element = getDocument(activeElement).getElementById(id);\n\n      if (element) {\n        return element;\n      }\n    }\n  }\n\n  return activeElement as HTMLElement | null;\n}\n\n/**\n * Returns `element.ownerDocument.defaultView || window`.\n */\nexport function getWindow(node?: Node | null): Window {\n  return getDocument(node).defaultView || window;\n}\n\n/**\n * Returns `element.ownerDocument || document`.\n */\nexport function getDocument(node?: Node | null): Document {\n  return node ? node.ownerDocument || (node as Document) : document;\n}\n\n/**\n * Checks whether `element` is a frame element.\n */\nexport function isFrame(element: Element): element is HTMLIFrameElement {\n  return element.tagName === \"IFRAME\";\n}\n","export enum EventKey {\n  Escape = \"Escape\",\n  Enter = \"Enter\",\n  Tab = \"Tab\",\n  Space = \" \",\n  ArrowDown = \"ArrowDown\",\n  ArrowLeft = \"ArrowLeft\",\n  ArrowRight = \"ArrowRight\",\n  ArrowUp = \"ArrowUp\",\n  End = \"End\",\n  Home = \"Home\",\n  PageDown = \"PageDown\",\n  PageUp = \"PageUp\",\n}\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/cf9ab24f3255be1530d0f584061a01aa1e8180e6/packages/@react-aria/utils/src/platform.ts\n */\n\nfunction testUserAgent(re: RegExp) {\n  if (typeof window === \"undefined\" || window.navigator == null) {\n    return false;\n  }\n  return (\n    // @ts-ignore\n    window.navigator[\"userAgentData\"]?.brands.some((brand: { brand: string; version: string }) =>\n      re.test(brand.brand),\n    ) || re.test(window.navigator.userAgent)\n  );\n}\n\nfunction testPlatform(re: RegExp) {\n  return typeof window !== \"undefined\" && window.navigator != null\n    ? // @ts-ignore\n      re.test(window.navigator[\"userAgentData\"]?.platform || window.navigator.platform)\n    : false;\n}\n\nexport function isMac() {\n  return testPlatform(/^Mac/i);\n}\n\nexport function isIPhone() {\n  return testPlatform(/^iPhone/i);\n}\n\nexport function isIPad() {\n  return (\n    testPlatform(/^iPad/i) ||\n    // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    (isMac() && navigator.maxTouchPoints > 1)\n  );\n}\n\nexport function isIOS() {\n  return isIPhone() || isIPad();\n}\n\nexport function isAppleDevice() {\n  return isMac() || isIOS();\n}\n\nexport function isWebKit() {\n  return testUserAgent(/AppleWebKit/i) && !isChrome();\n}\n\nexport function isChrome() {\n  return testUserAgent(/Chrome/i);\n}\n\nexport function isAndroid() {\n  return testUserAgent(/Android/i);\n}\n","import { JSX } from \"solid-js\";\n\nimport { isFunction } from \"./assertion\";\nimport { isMac } from \"./platform\";\n\n/** Call a JSX.EventHandlerUnion with the event. */\nexport function callHandler<T, E extends Event>(\n  event: E & { currentTarget: T; target: Element },\n  handler: JSX.EventHandlerUnion<T, E> | undefined,\n) {\n  if (handler) {\n    if (isFunction(handler)) {\n      handler(event);\n    } else {\n      handler[0](handler[1], event);\n    }\n  }\n\n  return event?.defaultPrevented;\n}\n\n/** Create a new event handler which calls all given handlers in the order they were chained with the same event. */\nexport function composeEventHandlers<T>(\n  handlers: Array<JSX.EventHandlerUnion<T, any> | undefined>,\n) {\n  return (event: any) => {\n    for (const handler of handlers) {\n      callHandler(event, handler);\n    }\n  };\n}\n\nexport function isCtrlKey(e: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\">) {\n  if (isMac()) {\n    return e.metaKey && !e.ctrlKey;\n  }\n\n  return e.ctrlKey && !e.metaKey;\n}\n","// External libs re-exports\nexport { createEventListener } from \"@solid-primitives/event-listener\";\nexport { Key } from \"@solid-primitives/keyed\";\nexport { ReactiveMap } from \"@solid-primitives/map\";\nexport { createMediaQuery } from \"@solid-primitives/media\";\nexport { combineProps } from \"@solid-primitives/props\";\nexport { mergeRefs } from \"@solid-primitives/refs\";\nexport type { MaybeAccessor } from \"@solid-primitives/utils\";\nexport { access, accessWith, chain } from \"@solid-primitives/utils\";\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/utils/src/focusWithoutScrolling.ts\n */\n\n// This is a polyfill for element.focus({preventScroll: true});\n// Currently necessary for Safari and old Edge:\n// https://caniuse.com/#feat=mdn-api_htmlelement_focus_preventscroll_option\n// See https://bugs.webkit.org/show_bug.cgi?id=178583\n\n// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n\ninterface ScrollableElement {\n  element: HTMLElement;\n  scrollTop: number;\n  scrollLeft: number;\n}\n\nexport function focusWithoutScrolling(element: HTMLElement | null | undefined) {\n  if (!element) {\n    return;\n  }\n\n  if (supportsPreventScroll()) {\n    element.focus({ preventScroll: true });\n  } else {\n    const scrollableElements = getScrollableElements(element);\n    element.focus();\n    restoreScrollPosition(scrollableElements);\n  }\n}\n\nlet supportsPreventScrollCached: boolean | null = null;\n\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false;\n    try {\n      const focusElem = document.createElement(\"div\");\n      focusElem.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true;\n          return true;\n        },\n      });\n    } catch (e) {\n      // Ignore\n    }\n  }\n\n  return supportsPreventScrollCached;\n}\n\nfunction getScrollableElements(element: HTMLElement): ScrollableElement[] {\n  let parent = element.parentNode;\n  const scrollableElements: ScrollableElement[] = [];\n  const rootScrollingElement = document.scrollingElement || document.documentElement;\n\n  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {\n    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft,\n      });\n    }\n    parent = parent.parentNode;\n  }\n\n  if (rootScrollingElement instanceof HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft,\n    });\n  }\n\n  return scrollableElements;\n}\n\nfunction restoreScrollPosition(scrollableElements: ScrollableElement[]) {\n  for (const { element, scrollTop, scrollLeft } of scrollableElements) {\n    element.scrollTop = scrollTop;\n    element.scrollLeft = scrollLeft;\n  }\n}\n","/*!\n * Portions of this file are based on code from ariakit.\n * MIT Licensed, Copyright (c) Diego Haz.\n *\n * Credits to the Ariakit team:\n * https://github.com/ariakit/ariakit/blob/main/packages/ariakit-utils/src/focus.ts\n *\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/focus/src/isElementVisible.ts\n * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/focus/src/FocusScope.tsx\n */\n\nimport { contains, getActiveElement, isFrame } from \"./dom\";\n\nconst focusableElements = [\n  \"input:not([type='hidden']):not([disabled])\",\n  \"select:not([disabled])\",\n  \"textarea:not([disabled])\",\n  \"button:not([disabled])\",\n  \"a[href]\",\n  \"area[href]\",\n  \"[tabindex]\",\n  \"iframe\",\n  \"object\",\n  \"embed\",\n  \"audio[controls]\",\n  \"video[controls]\",\n  \"[contenteditable]:not([contenteditable='false'])\",\n];\n\nconst tabbableElements = [...focusableElements, '[tabindex]:not([tabindex=\"-1\"]):not([disabled])'];\n\nexport const FOCUSABLE_ELEMENT_SELECTOR =\n  focusableElements.join(\":not([hidden]),\") + \",[tabindex]:not([disabled]):not([hidden])\";\n\nexport const TABBABLE_ELEMENT_SELECTOR = tabbableElements.join(\n  ':not([hidden]):not([tabindex=\"-1\"]),',\n);\n\n/**\n * Returns all the tabbable elements in `container`.\n */\nexport function getAllTabbableIn(container: HTMLElement, includeContainer?: boolean) {\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENT_SELECTOR));\n\n  const tabbableElements = elements.filter(isTabbable);\n\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container);\n  }\n\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      const allFrameTabbable = getAllTabbableIn(frameBody, false);\n      tabbableElements.splice(i, 1, ...allFrameTabbable);\n    }\n  });\n\n  return tabbableElements;\n}\n\n/**\n * Checks whether `element` is tabbable or not.\n * @example\n * isTabbable(document.querySelector(\"input\")); // true\n * isTabbable(document.querySelector(\"input[tabindex='-1']\")); // false\n * isTabbable(document.querySelector(\"input[hidden]\")); // false\n * isTabbable(document.querySelector(\"input:disabled\")); // false\n */\nexport function isTabbable(element: Element): element is HTMLElement {\n  return isFocusable(element) && !hasNegativeTabIndex(element);\n}\n\n/**\n * Checks whether `element` is focusable or not.\n * @example\n * isFocusable(document.querySelector(\"input\")); // true\n * isFocusable(document.querySelector(\"input[tabindex='-1']\")); // true\n * isFocusable(document.querySelector(\"input[hidden]\")); // false\n * isFocusable(document.querySelector(\"input:disabled\")); // false\n */\nexport function isFocusable(element: Element): element is HTMLElement {\n  return element.matches(FOCUSABLE_ELEMENT_SELECTOR) && isElementVisible(element);\n}\n\nfunction hasNegativeTabIndex(element: Element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10);\n  return tabIndex < 0;\n}\n\n/**\n * Adapted from https://github.com/testing-library/jest-dom and\n * https://github.com/vuejs/vue-test-utils-next/.\n * Licensed under the MIT License.\n * @param element - Element to evaluate for display or visibility.\n */\nexport function isElementVisible(element: Element, childElement?: Element): boolean {\n  return (\n    element.nodeName !== \"#comment\" &&\n    isStyleVisible(element) &&\n    isAttributeVisible(element, childElement) &&\n    (!element.parentElement || isElementVisible(element.parentElement, element))\n  );\n}\n\nfunction isStyleVisible(element: Element) {\n  if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) {\n    return false;\n  }\n\n  const { display, visibility } = element.style;\n\n  let isVisible = display !== \"none\" && visibility !== \"hidden\" && visibility !== \"collapse\";\n\n  if (isVisible) {\n    if (!element.ownerDocument.defaultView) {\n      return isVisible;\n    }\n\n    const { getComputedStyle } = element.ownerDocument.defaultView;\n    const { display: computedDisplay, visibility: computedVisibility } = getComputedStyle(element);\n\n    isVisible =\n      computedDisplay !== \"none\" &&\n      computedVisibility !== \"hidden\" &&\n      computedVisibility !== \"collapse\";\n  }\n\n  return isVisible;\n}\n\nfunction isAttributeVisible(element: Element, childElement?: Element) {\n  return (\n    !element.hasAttribute(\"hidden\") &&\n    (element.nodeName === \"DETAILS\" && childElement && childElement.nodeName !== \"SUMMARY\"\n      ? element.hasAttribute(\"open\")\n      : true)\n  );\n}\n\n/**\n * Checks if `element` has focus within.\n * Elements that are referenced by `aria-activedescendant` are also considered.\n * @example\n * hasFocusWithin(document.getElementById(\"id\"));\n */\nexport function hasFocusWithin(element: Node | Element) {\n  const activeElement = getActiveElement(element);\n\n  if (!activeElement) {\n    return false;\n  }\n\n  if (!contains(element, activeElement)) {\n    const activeDescendant = activeElement.getAttribute(\"aria-activedescendant\");\n    if (!activeDescendant) {\n      return false;\n    }\n    if (!(\"id\" in element)) {\n      return false;\n    }\n    if (activeDescendant === element.id) {\n      return true;\n    }\n    return !!element.querySelector(`#${CSS.escape(activeDescendant)}`);\n  } else {\n    return true;\n  }\n}\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/f6e686fe9d3b983d48650980c1ecfdde320bc62f/packages/@react-aria/focus/src/FocusScope.tsx\n */\n\nimport { Accessor } from \"solid-js\";\n\nimport { focusWithoutScrolling } from \"./focus-without-scrolling\";\nimport {\n  FOCUSABLE_ELEMENT_SELECTOR,\n  isElementVisible,\n  TABBABLE_ELEMENT_SELECTOR,\n} from \"./tabbable\";\n\nexport interface FocusManager {\n  /** Moves focus to the next focusable or tabbable element in the focus scope. */\n  focusNext(opts?: FocusManagerOptions): HTMLElement | undefined;\n\n  /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n  focusPrevious(opts?: FocusManagerOptions): HTMLElement | undefined;\n\n  /** Moves focus to the first focusable or tabbable element in the focus scope. */\n  focusFirst(opts?: FocusManagerOptions): HTMLElement | undefined;\n\n  /** Moves focus to the last focusable or tabbable element in the focus scope. */\n  focusLast(opts?: FocusManagerOptions): HTMLElement | undefined;\n}\n\nexport interface FocusManagerOptions {\n  /** The element to start searching from. The currently focused element by default. */\n  from?: Element;\n\n  /** Whether to only include tabbable elements, or all focusable elements. */\n  tabbable?: boolean;\n\n  /** Whether focus should wrap around when it reaches the end of the scope. */\n  wrap?: boolean;\n\n  /** A callback that determines whether the given element is focused. */\n  accept?: (node: Element) => boolean;\n}\n\n/**\n * Creates a FocusManager object that can be used to move focus within an element.\n */\nexport function createFocusManager(\n  ref: Accessor<HTMLElement | undefined>,\n  defaultOptions: Accessor<FocusManagerOptions> = () => ({}),\n): FocusManager {\n  const focusNext = (opts: FocusManagerOptions = {}) => {\n    const root = ref();\n\n    if (!root) {\n      return;\n    }\n\n    const {\n      from = defaultOptions().from || document.activeElement,\n      tabbable = defaultOptions().tabbable,\n      wrap = defaultOptions().wrap,\n      accept = defaultOptions().accept,\n    } = opts;\n\n    const walker = getFocusableTreeWalker(root, { tabbable, accept });\n\n    if (from && root.contains(from)) {\n      walker.currentNode = from;\n    }\n\n    let nextNode = walker.nextNode() as HTMLElement | undefined;\n\n    if (!nextNode && wrap) {\n      walker.currentNode = root;\n      nextNode = walker.nextNode() as HTMLElement | undefined;\n    }\n\n    if (nextNode) {\n      focusElement(nextNode, true);\n    }\n\n    return nextNode;\n  };\n\n  const focusPrevious = (opts: FocusManagerOptions = {}) => {\n    const root = ref();\n\n    if (!root) {\n      return;\n    }\n\n    const {\n      from = defaultOptions().from || document.activeElement,\n      tabbable = defaultOptions().tabbable,\n      wrap = defaultOptions().wrap,\n      accept = defaultOptions().accept,\n    } = opts;\n\n    const walker = getFocusableTreeWalker(root, { tabbable, accept });\n\n    if (from && root.contains(from)) {\n      walker.currentNode = from;\n    } else {\n      const next = last(walker);\n      if (next) {\n        focusElement(next, true);\n      }\n      return next;\n    }\n\n    let previousNode = walker.previousNode() as HTMLElement | undefined;\n\n    if (!previousNode && wrap) {\n      walker.currentNode = root;\n      previousNode = last(walker);\n    }\n\n    if (previousNode) {\n      focusElement(previousNode, true);\n    }\n\n    return previousNode;\n  };\n\n  const focusFirst = (opts: FocusManagerOptions = {}) => {\n    const root = ref();\n\n    if (!root) {\n      return;\n    }\n\n    const { tabbable = defaultOptions().tabbable, accept = defaultOptions().accept } = opts;\n\n    const walker = getFocusableTreeWalker(root, { tabbable, accept });\n    const nextNode = walker.nextNode() as HTMLElement | undefined;\n\n    if (nextNode) {\n      focusElement(nextNode, true);\n    }\n\n    return nextNode;\n  };\n\n  const focusLast = (opts: FocusManagerOptions = {}) => {\n    const root = ref();\n\n    if (!root) {\n      return;\n    }\n\n    const { tabbable = defaultOptions().tabbable, accept = defaultOptions().accept } = opts;\n\n    const walker = getFocusableTreeWalker(root, { tabbable, accept });\n    const next = last(walker);\n\n    if (next) {\n      focusElement(next, true);\n    }\n\n    return next;\n  };\n\n  return { focusNext, focusPrevious, focusFirst, focusLast };\n}\n\nfunction focusElement(element: HTMLElement | null, scroll = false) {\n  if (element != null && !scroll) {\n    try {\n      focusWithoutScrolling(element);\n    } catch (err) {\n      // ignore\n    }\n  } else if (element != null) {\n    try {\n      element.focus();\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n\nfunction last(walker: TreeWalker) {\n  let next: HTMLElement | undefined;\n  let last: HTMLElement | undefined;\n\n  do {\n    last = walker.lastChild() as HTMLElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n\n  return next;\n}\n\nfunction isElementInScope(element: Element | null, scope: HTMLElement[]) {\n  return scope.some(node => node.contains(element));\n}\n\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(\n  root: HTMLElement,\n  opts?: FocusManagerOptions,\n  scope?: HTMLElement[],\n) {\n  const selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n    acceptNode(node) {\n      // Skip nodes inside the starting node.\n      if (opts?.from?.contains(node)) {\n        return NodeFilter.FILTER_REJECT;\n      }\n\n      if (\n        (node as HTMLElement).matches(selector) &&\n        isElementVisible(node as HTMLElement) &&\n        (!scope || isElementInScope(node as HTMLElement, scope)) &&\n        (!opts?.accept || opts.accept(node as Element))\n      ) {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n\n      return NodeFilter.FILTER_SKIP;\n    },\n  });\n\n  if (opts?.from) {\n    walker.currentNode = opts.from;\n  }\n\n  return walker;\n}\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/utils/src/getScrollParent.ts\n */\n\nexport function getScrollParent(node: Element | null): Element {\n  while (node && !isScrollable(node)) {\n    node = node.parentElement;\n  }\n\n  return node || document.scrollingElement || document.documentElement;\n}\n\nfunction isScrollable(node: Element): boolean {\n  const style = window.getComputedStyle(node);\n  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/utils/src/isVirtualEvent.ts\n */\n\n// Original licensing for the following method can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/blob/3c713d513195a53788b3f8bb4b70279d68b15bcc/packages/react-interactions/events/src/dom/shared/index.js#L74-L87\n\nimport { isAndroid } from \"./platform\";\n\n// Keyboards, Assistive Technologies, and element.click() all produce a \"virtual\"\n// click event. This is a method of inferring such clicks. Every browser except\n// IE 11 only sets a zero value of \"detail\" for click events that are \"virtual\".\n// However, IE 11 uses a zero value for all click events. For IE 11 we rely on\n// the quirk that it produces click events that are of type PointerEvent, and\n// where only the \"virtual\" click lacks a pointerType field.\n\nexport function isVirtualClick(event: MouseEvent | PointerEvent): boolean {\n  // JAWS/NVDA with Firefox.\n  if ((event as any).mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n\n  // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n  // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n  // to detect TalkBack virtual clicks.\n  if (isAndroid() && (event as PointerEvent).pointerType) {\n    return event.type === \"click\" && event.buttons === 1;\n  }\n\n  return event.detail === 0 && !(event as PointerEvent).pointerType;\n}\n\nexport function isVirtualPointerEvent(event: PointerEvent) {\n  // If the pointer size is zero, then we assume it's from a screen reader.\n  // Android TalkBack double tap will sometimes return a event with width and height of 1\n  // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n  // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n  // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n  // Talkback double tap from Windows Firefox touch screen press\n  return (\n    (event.width === 0 && event.height === 0) ||\n    (event.width === 1 &&\n      event.height === 1 &&\n      event.pressure === 0 &&\n      event.detail === 0 &&\n      event.pointerType === \"mouse\")\n  );\n}\n","/** A function that does nothing. */\nexport function noop() {\n  return;\n}\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/ff3e690fffc6c54367b8057e28a0e5b9211f37b5/packages/@react-stately/utils/src/number.ts\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min = -Infinity, max = Infinity): number {\n  return Math.min(Math.max(value, min), max);\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  const remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  let snappedValue =\n    Math.abs(remainder) * 2 >= step\n      ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n      : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  const string = step.toString();\n  const index = string.indexOf(\".\");\n  const precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    const pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n","/*!\n * Portions of this file are based on code from ariakit.\n * MIT Licensed, Copyright (c) Diego Haz.\n *\n * Credits to the Ariakit team:\n * https://github.com/ariakit/ariakit/blob/84e97943ad637a582c01c9b56d880cd95f595737/packages/ariakit/src/hovercard/__utils/polygon.ts\n * https://github.com/ariakit/ariakit/blob/f2a96973de523d67e41eec983263936c489ef3e2/packages/ariakit/src/hovercard/__utils/debug-polygon.ts\n */\n\nexport type Point = [number, number];\nexport type Polygon = Point[];\n\nexport function getEventPoint(event: MouseEvent): Point {\n  return [event.clientX, event.clientY];\n}\n\n// Based on https://github.com/metafloor/pointinpoly\nexport function isPointInPolygon(point: Point, polygon: Polygon) {\n  const [x, y] = point;\n  let inside = false;\n  const length = polygon.length;\n  for (let l = length, i = 0, j = l - 1; i < l; j = i++) {\n    const [xi, yi] = polygon[i] as Point;\n    const [xj, yj] = polygon[j] as Point;\n    const [, vy] = polygon[j === 0 ? l - 1 : j - 1] || [0, 0];\n    const where = (yi - yj) * (x - xi) - (xi - xj) * (y - yi);\n    if (yj < yi) {\n      if (y >= yj && y < yi) {\n        // point on the line\n        if (where === 0) return true;\n        if (where > 0) {\n          if (y === yj) {\n            // ray intersects vertex\n            if (y > vy) {\n              inside = !inside;\n            }\n          } else {\n            inside = !inside;\n          }\n        }\n      }\n    } else if (yi < yj) {\n      if (y > yi && y <= yj) {\n        // point on the line\n        if (where === 0) return true;\n        if (where < 0) {\n          if (y === yj) {\n            // ray intersects vertex\n            if (y < vy) {\n              inside = !inside;\n            }\n          } else {\n            inside = !inside;\n          }\n        }\n      }\n    } else if (y == yi && ((x >= xj && x <= xi) || (x >= xi && x <= xj))) {\n      // point on horizontal edge\n      return true;\n    }\n  }\n  return inside;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Debug polygon\n * -----------------------------------------------------------------------------------------------*/\n\nfunction getPolygon() {\n  const id = \"debug-polygon\";\n  const existingPolygon = document.getElementById(id);\n  if (existingPolygon) {\n    return existingPolygon;\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  svg.style.top = \"0\";\n  svg.style.left = \"0\";\n  svg.style.width = \"100%\";\n  svg.style.height = \"100%\";\n  svg.style.fill = \"green\";\n  svg.style.opacity = \"0.2\";\n  svg.style.position = \"fixed\";\n  svg.style.pointerEvents = \"none\";\n  svg.style.zIndex = \"999999\";\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n  polygon.setAttribute(\"id\", id);\n  polygon.setAttribute(\"points\", \"0,0 0,0\");\n  svg.appendChild(polygon);\n  document.body.appendChild(svg);\n  return polygon;\n}\n\nexport function debugPolygon(polygon: Polygon) {\n  const polygonElement = getPolygon();\n  const points = polygon.map(point => point.join(\",\")).join(\" \");\n  polygonElement.setAttribute(\"points\", points);\n  // Return SVG element\n  return polygonElement.parentElement;\n}\n","import { ComponentProps, mergeProps, ValidComponent } from \"solid-js\";\n\n/**\n * Allows for extending a set of props (`Source`) by an overriding set of props (`Override`),\n * ensuring that any duplicates are overridden by the overriding set of props.\n */\nexport type OverrideProps<Source = {}, Override = {}> = Omit<Source, keyof Override> & Override;\n\n/**\n * Allows for extending a set of `ComponentProps` by an overriding set of props,\n * ensuring that any duplicates are overridden by the overriding set of props.\n */\nexport type OverrideComponentProps<T extends ValidComponent, P> = OverrideProps<\n  ComponentProps<T>,\n  P\n>;\n\nexport function mergeDefaultProps<T extends Record<string, any>>(\n  defaultProps: Partial<T>,\n  props: T,\n): T {\n  return mergeProps(defaultProps, props);\n}\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/utils/src/runAfterTransition.ts\n */\n\n// We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nconst transitionsByElement = new Map<EventTarget, Set<string>>();\n\n// A list of callbacks to call once there are no transitioning elements.\nconst transitionCallbacks = new Set<() => void>();\n\nfunction setupGlobalEvents() {\n  if (typeof window === \"undefined\") {\n    return;\n  }\n\n  const onTransitionStart = (e: TransitionEvent) => {\n    if (!e.target) {\n      return;\n    }\n\n    // Add the transitioning property to the list for this element.\n    let transitions = transitionsByElement.get(e.target);\n    if (!transitions) {\n      transitions = new Set();\n      transitionsByElement.set(e.target, transitions);\n\n      // The transitioncancel event must be registered on the element itself, rather than as a global\n      // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n      // In that case, the cancel event would have nowhere to bubble to, so we need to handle it directly.\n      e.target.addEventListener(\"transitioncancel\", onTransitionEnd as EventListener);\n    }\n\n    transitions.add(e.propertyName);\n  };\n\n  const onTransitionEnd = (e: TransitionEvent) => {\n    if (!e.target) {\n      return;\n    }\n\n    // Remove property from list of transitioning properties.\n    const properties = transitionsByElement.get(e.target);\n    if (!properties) {\n      return;\n    }\n\n    properties.delete(e.propertyName);\n\n    // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n    if (properties.size === 0) {\n      e.target.removeEventListener(\"transitioncancel\", onTransitionEnd as EventListener);\n      transitionsByElement.delete(e.target);\n    }\n\n    // If no transitioning elements, call all the queued callbacks.\n    if (transitionsByElement.size === 0) {\n      for (const cb of transitionCallbacks) {\n        cb();\n      }\n\n      transitionCallbacks.clear();\n    }\n  };\n\n  document.body.addEventListener(\"transitionrun\", onTransitionStart);\n  document.body.addEventListener(\"transitionend\", onTransitionEnd);\n}\n\nif (typeof document !== \"undefined\") {\n  if (document.readyState !== \"loading\") {\n    setupGlobalEvents();\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", setupGlobalEvents);\n  }\n}\n\nexport function runAfterTransition(fn: () => void) {\n  // Wait one frame to see if an animation starts, e.g. a transition on mount.\n  requestAnimationFrame(() => {\n    // If no transitions are running, call the function immediately.\n    // Otherwise, add it to a list of callbacks to run at the end of the animation.\n    if (transitionsByElement.size === 0) {\n      fn();\n    } else {\n      transitionCallbacks.add(fn);\n    }\n  });\n}\n","/*!\n * Portions of this file are based on code from react-spectrum.\n * Apache License Version 2.0, Copyright 2020 Adobe.\n *\n * Credits to the React Spectrum team:\n * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/utils/src/scrollIntoView.ts\n */\n\nimport { getScrollParent } from \"./get-scroll-parent\";\n\ninterface ScrollIntoViewportOpts {\n  /** The optional containing element of the target to be centered in the viewport. */\n  containingElement?: Element;\n}\n\n/**\n * Scrolls `scrollView` so that `element` is visible.\n * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),\n * but doesn't affect parents above `scrollView`.\n */\nexport function scrollIntoView(scrollView: HTMLElement, element: HTMLElement) {\n  const offsetX = relativeOffset(scrollView, element, \"left\");\n  const offsetY = relativeOffset(scrollView, element, \"top\");\n  const width = element.offsetWidth;\n  const height = element.offsetHeight;\n  let x = scrollView.scrollLeft;\n  let y = scrollView.scrollTop;\n  const maxX = x + scrollView.offsetWidth;\n  const maxY = y + scrollView.offsetHeight;\n\n  if (offsetX <= x) {\n    x = offsetX;\n  } else if (offsetX + width > maxX) {\n    x += offsetX + width - maxX;\n  }\n  if (offsetY <= y) {\n    y = offsetY;\n  } else if (offsetY + height > maxY) {\n    y += offsetY + height - maxY;\n  }\n\n  scrollView.scrollLeft = x;\n  scrollView.scrollTop = y;\n}\n\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */\nfunction relativeOffset(ancestor: HTMLElement, child: HTMLElement, axis: \"left\" | \"top\") {\n  const prop = axis === \"left\" ? \"offsetLeft\" : \"offsetTop\";\n  let sum = 0;\n  while (child.offsetParent) {\n    sum += child[prop];\n    if (child.offsetParent === ancestor) {\n      // Stop once we have found the ancestor we are interested in.\n      break;\n    } else if (child.offsetParent.contains(ancestor)) {\n      // If the ancestor is not `position:relative`, then we stop at\n      // _its_ offset parent, and we subtract off _its_ offset, so that\n      // we end up with the proper offset from child to ancestor.\n      sum -= ancestor[prop];\n      break;\n    }\n    child = child.offsetParent as HTMLElement;\n  }\n  return sum;\n}\n\n/**\n * Scrolls the `targetElement` so it is visible in the viewport. Accepts an optional `opts.containingElement`\n * that will be centered in the viewport prior to scrolling the targetElement into view. If scrolling is prevented on\n * the body (e.g. targetElement is in a popover), this will only scroll the scroll parents of the targetElement up to but not including the body itself.\n */\nexport function scrollIntoViewport(targetElement: Element, opts?: ScrollIntoViewportOpts) {\n  if (document.contains(targetElement)) {\n    const root = document.scrollingElement || document.documentElement;\n    const isScrollPrevented = window.getComputedStyle(root).overflow === \"hidden\";\n    // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n    if (!isScrollPrevented) {\n      const { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();\n\n      // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()\n      // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n      targetElement?.scrollIntoView?.({ block: \"nearest\" });\n      const { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();\n      // Account for sub pixel differences from rounding\n      if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {\n        opts?.containingElement?.scrollIntoView?.({ block: \"center\", inline: \"center\" });\n        targetElement.scrollIntoView?.({ block: \"nearest\" });\n      }\n    } else {\n      let scrollParent = getScrollParent(targetElement);\n      // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n      while (targetElement && scrollParent && targetElement !== root && scrollParent !== root) {\n        scrollIntoView(scrollParent as HTMLElement, targetElement as HTMLElement);\n        targetElement = scrollParent;\n        scrollParent = getScrollParent(targetElement);\n      }\n    }\n  }\n}\n","import { JSX } from \"solid-js\";\n\nexport const visuallyHiddenStyles: JSX.CSSProperties = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  \"clip-path\": \"inset(50%)\",\n  height: \"1px\",\n  margin: \"0 -1px -1px 0\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  \"white-space\": \"nowrap\",\n};\n"]}