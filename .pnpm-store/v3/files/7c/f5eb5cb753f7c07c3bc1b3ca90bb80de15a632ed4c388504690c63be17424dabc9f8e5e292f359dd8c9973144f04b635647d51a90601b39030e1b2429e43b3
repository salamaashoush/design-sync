import { resolve } from 'node:path';
import { constants, writeFileAsync } from '@create-figma-plugin/common';
import { globby } from 'globby';
import { importFresh } from './import-fresh.js';
export async function buildManifestAsync(options) {
    const { config, minify, outputDirectory } = options;
    const { api, widgetApi, editorType, containsWidget, commandId, id, name, main, ui, menu, parameters, parameterOnly, relaunchButtons, capabilities, permissions, networkAccess, enablePrivatePluginApi, enableProposedApi, build, rest } = config;
    const command = { commandId, name, main, ui, menu, parameters, parameterOnly };
    if (hasBundle(command, 'main') === false) {
        throw new Error('Need a `main` entry point');
    }
    const hasUi = hasBundle(command, 'ui') === true ||
        (relaunchButtons !== null &&
            relaunchButtons.filter(function (relaunchButton) {
                return relaunchButton.ui !== null;
            }).length > 0);
    const manifest = {
        api,
        widgetApi: containsWidget === true ? widgetApi : undefined,
        editorType,
        containsWidget: containsWidget === true ? containsWidget : undefined,
        id,
        name,
        main: constants.build.pluginCodeFilePath,
        ui: hasUi === true ? constants.build.pluginUiFilePath : undefined,
        menu: command.menu !== null ? createManifestMenu(command.menu) : undefined,
        parameters: command.parameters !== null
            ? createManifestParameters(command.parameters)
            : undefined,
        parameterOnly: command.parameterOnly === false ? false : undefined,
        relaunchButtons: relaunchButtons !== null
            ? createManifestRelaunchButtons(relaunchButtons)
            : undefined,
        capabilities: capabilities !== null ? capabilities : undefined,
        permissions: permissions !== null ? permissions : undefined,
        networkAccess: networkAccess !== null
            ? createManifestNetworkAccess(networkAccess)
            : undefined,
        enableProposedApi: enableProposedApi === true ? true : undefined,
        enablePrivatePluginApi: enablePrivatePluginApi === true ? true : undefined,
        build: build !== null ? build : undefined,
        ...(rest !== null ? rest : {})
    };
    const result = await overrideManifestAsync(manifest);
    const string = (minify === true
        ? JSON.stringify(result)
        : JSON.stringify(result, null, 2)) + '\n';
    const outputFilePath = resolve(outputDirectory, constants.build.manifestFilePath);
    await writeFileAsync(outputFilePath, string);
}
function hasBundle(command, key) {
    if (command[key] !== null) {
        return true;
    }
    if (command.menu !== null) {
        const result = command.menu.filter(function (command) {
            if ('separator' in command) {
                return false;
            }
            return hasBundle(command, key);
        });
        return result.length > 0;
    }
    return false;
}
function createManifestParameters(parameters) {
    return parameters.map(function (parameter) {
        const result = {
            key: parameter.key,
            name: parameter.name
        };
        if (parameter.description !== null) {
            result.description = parameter.description;
        }
        if (parameter.allowFreeform === true) {
            result.allowFreeform = true;
        }
        if (parameter.optional === true) {
            result.optional = true;
        }
        return result;
    });
}
function createManifestMenu(menu) {
    return menu.map(function (item) {
        if ('separator' in item) {
            return { separator: true };
        }
        const result = {
            name: item.name
        };
        if (item.commandId !== null) {
            result.command = item.commandId;
        }
        if (item.parameters !== null) {
            result.parameters = createManifestParameters(item.parameters);
        }
        if (item.parameterOnly === false) {
            result.parameterOnly = false;
        }
        if (item.menu !== null) {
            result.menu = createManifestMenu(item.menu);
        }
        return result;
    });
}
function createManifestRelaunchButtons(relaunchButtons) {
    return relaunchButtons.map(function (relaunchButton) {
        const result = {
            name: relaunchButton.name,
            command: relaunchButton.commandId
        };
        if (relaunchButton.multipleSelection === true) {
            result.multipleSelection = true;
        }
        return result;
    });
}
function createManifestNetworkAccess(networkAccess) {
    const { allowedDomains, devAllowedDomains, reasoning } = networkAccess;
    const result = {
        allowedDomains
    };
    if (devAllowedDomains !== null) {
        result.devAllowedDomains = devAllowedDomains;
    }
    if (reasoning !== null) {
        result.reasoning = reasoning;
    }
    return result;
}
async function overrideManifestAsync(manifest) {
    const filePaths = await globby(constants.build.manifestConfigGlobPattern, {
        absolute: true
    });
    if (filePaths.length === 0) {
        return manifest;
    }
    const { default: overrideManifest } = await importFresh(filePaths[0]);
    return overrideManifest(manifest);
}
//# sourceMappingURL=build-manifest-async.js.map